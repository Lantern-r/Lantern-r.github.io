<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>Java 笔记 | Lantern's 小站</title><meta name="author" content="Lantern"><meta name="copyright" content="Lantern"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java学习笔记"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lantern.cool/note-language-java-note/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c586340026fb7073260722fcc798b88b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-165381350-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-165381350-1")</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Java 笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2020-05-13 01:25:09"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Lantern's 小站" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/lantern.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-cubes"></i> <span>自言自语</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files@latest/img/pexels-greg-contreras-3177804.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="Lantern's 小站"><span class="site-name">Lantern's 小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-cubes"></i> <span>自言自语</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-13T01:25:09.000Z" title="发表于 2020-05-13 01:25:09">2020-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-05-13T01:25:09.000Z" title="更新于 2020-05-13 01:25:09">2020-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Note/">Note</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Note/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Java 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>跟着b站大学<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1T7411m7Ta%E5%AD%A6%E4%B9%A0java">https://www.bilibili.com/video/BV1T7411m7Ta学习java</a>的读书笔记</li><li>使用的是<code>Java 8</code></li></ul><h2 id="Java语言开发环境的搭建"><a href="#Java语言开发环境的搭建" class="headerlink" title="Java语言开发环境的搭建"></a>Java语言开发环境的搭建</h2><h3 id="Java虚拟机——JVM"><a href="#Java虚拟机——JVM" class="headerlink" title="Java虚拟机——JVM"></a>Java虚拟机——JVM</h3><ul><li><p><strong>JVM</strong>(java Virtual Machine) : Java虚拟机, 是运行所有Java程序的假想计算机, 是Java程序的运行环境, 是Java最具吸引力的特性之一, 我们编写的Java代码, 都运在<code>JVM</code>之上</p></li><li><p><strong>跨平台</strong>:任何软件的运行, 都必须要运行在操作系统之上, 而我们用Java编写的软件可以在任何的操作系统上, 这个特性称为<strong>Java语言的跨平台性</strong>, 该特性是由JVM实现的, 我们编写的程序运行在JVM上, 而JVM运行在操作系统上</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-cross_platform.jpg" alt="java-cross_platform"></p></li><li><p>如图, java的虚拟机本身不具备跨平台功能的, 每个操作系统下都由不同版本的虚拟机</p></li></ul><h3 id="JRE-和-JDK"><a href="#JRE-和-JDK" class="headerlink" title="JRE 和 JDK"></a>JRE 和 JDK</h3><ul><li><p><strong>JRE</strong><code>(Java Runtime Environmen)</code> : 是Java程序的运行时环境, 包含<code>JVM</code>和运行时所需要的<code>核心类库</code></p></li><li><p><strong>JDK</strong>（<code>Java Development Kit</code>）: 是Java程序开发工具包, 包含<code>JRE</code>和开发人员使用的工具</p></li><li><p>关系</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-relation.jpg" alt="java-relation"></p></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul><li>有特殊含义、被保留的、不能随意使用的字符</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><code>在程序运行的过程中不会改变的量</code></p><ol><li>字符串常量, <code>&quot; &quot;</code>双引号引起来的部分, 例如<code>&quot;abd&quot;、 &quot;Hello&quot;、“123”</code></li><li>整数常量, 例如: <code>100, 200, 0, -250</code></li><li>浮点数常量, 例如:<code>2.5, -3.14</code></li><li>字符串常量, 例如: <code>&#39;A&#39;, ’b‘, &#39;9&#39;, &#39;中&#39;</code><ul><li>Java中的一个char类型标识一个utf-16编码的代码单元, 也就是两个字节, 因此, 不像C语言中文无法代表一个字符</li><li>char真实的含义是描述了UTF-16编码中的一个<strong>代码单元</strong>, 而不是一个<strong>字符</strong></li></ul></li><li>布尔常量, <code>true, false</code></li><li>空常量, <code>null</code>, 代表没有任何数据</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li>整数型: <code>byte</code> <code>short</code> <code>int</code> <code>long</code></li><li>浮点型: <code>float</code> <code>double</code><ul><li>浮点型可能只是一个近似值, 并非精确值, 例如<code>1/3</code>是无法精确表示的</li></ul></li><li>字符型: <code>char</code></li><li>布尔型: <code>boolean</code></li></ul><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul><li>字符串、数组、类、接口、Lambda</li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>这部分和C/C++几乎一样, 我直接跳掉了</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><code>参数</code>:进入方法的数据（可以没有）</li><li><code>返回值</code>: 方法执行后的数据结果（可以没有）</li><li><code>修饰符</code>: 例如<code>public static</code></li><li><code>返回类型</code>:对应返回值的类型</li><li><code>方法名称</code>:方法名字, 规则与变量意义, 建议符合驼峰命名法</li><li><code>参数类型</code>:对应参数的类型</li><li><code>方法体</code>:方法需要做的事情, 若干代码</li><li><code>return</code>: （可以没有）<ul><li>将返回值返还调用处</li><li>终止当前方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名称(参数类型 参数名称, ....) &#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-function-call.jpg" alt="java-function-call"></p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><ul><li>名字相同, 但参数列表不同的方法</li><li>用于对类似功能的方法的名称进行复用, 也就是记住一个名称就可以使用类似的功, 例如<code>println()</code>就进行了多种类型的重载, 使得我们只需要记住<code>println()</code>就可以了。</li></ul><p>以数字相加为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>不能方法嵌套定义</p></li><li><p>方法定义顺序无所谓</p></li><li><p><code>void</code>方法可以写<code>return</code>, 也可以不写</p></li><li><p>重载</p><ul><li><p>参数个数不同</p></li><li><p>参数类型不同</p></li><li><p>参数的多类型顺序不同</p><p>下面例子是允许的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>任何数据类型都可以存放在数组中</p><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">double</span>[] array = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">String[] array = <span class="keyword">new</span> String[<span class="number">10</span>]</span><br></pre></td></tr></table></figure><ul><li>初始化默认值:<ul><li>整数类型, <code>0</code></li><li>浮点类型, <code>0.0</code></li><li>字符类型, <code>\u0000</code></li><li>布尔类型, <code>false</code></li><li>引用类型, <code>null</code></li></ul></li></ul><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] array = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="省略格式"><a href="#省略格式" class="headerlink" title="省略格式"></a>省略格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrayA = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="数组越界异常（ArrayIndexOutOfBoundsException）"><a href="#数组越界异常（ArrayIndexOutOfBoundsException）" class="headerlink" title="数组越界异常（ArrayIndexOutOfBoundsException）"></a>数组越界异常（ArrayIndexOutOfBoundsException）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line">        System.out.println(array[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 2</span><br><span class="line">    at cn.itcast.day01.demo01.HelloWorld.main(HelloWorld.java:6)</span><br></pre></td></tr></table></figure><h5 id="空指针异常-NullPointerException"><a href="#空指针异常-NullPointerException" class="headerlink" title="空指针异常(NullPointerException)"></a>空指针异常(NullPointerException)</h5><p>数组必须new初始化才能使用, 如果只是赋值了一个null, 将发生空指针异常:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(array[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at cn.itcast.day01.demo01.HelloWorld.main(HelloWorld.java:6)</span><br></pre></td></tr></table></figure><h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><ul><li><p>获得: <code>array.length</code></p></li><li><p>数组一旦创建, 程序运行期间, 长度不可改变</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-array-length.jpg" alt="java-array-length"></p></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="栈-Stack）"><a href="#栈-Stack）" class="headerlink" title="栈(Stack）"></a>栈(Stack）</h4><ul><li>存放方法中的局部变量, 超出作用域立即从栈内存中消失</li></ul><h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h4><ul><li>凡是new出来的东西, 都在堆当中</li><li>堆内存里面的东西都有一个地址值:16进制</li><li>堆内的数据都有默认值</li></ul><h4 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h4><p>存放<code>.class</code>相关信息, 包含方法的信息</p><h4 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h4><p>与操作系统相关</p><h4 id="寄存器（Register）"><a href="#寄存器（Register）" class="headerlink" title="寄存器（Register）"></a>寄存器（Register）</h4><p>与CPU相关</p><h3 id="面向对象的思想"><a href="#面向对象的思想" class="headerlink" title="面向对象的思想"></a>面向对象的思想</h3><ul><li>面向过程, 每一步都亲力亲为</li><li>面向对象, 找一个已有功能帮助实现</li></ul><p>举例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印格式: [10, 20, 30, 40]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 面向过程</span></span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(array[i] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(array[i] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 面向对象</span></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li><strong>类</strong>:一组相关<strong>属性</strong>和<strong>行为</strong>的集合, 可以看成是一类事物的模板, 使用事物的属性特征和行为特征来描述该类事物。</li></ul><p>现实中, 描述一类事物:</p><ul><li><strong>属性</strong>: 就是该事物的状态信息,- <strong>行为</strong>: 就是该事物能够做什么</li></ul><p>举例: 小猫。</p><ul><li>属性: 名字、体重、年龄、颜色</li><li>行为: 走、跑、叫</li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li><strong>对象</strong>: 一类事物的具体体现, 对象是类的一个<strong>实例</strong>, 必然具备该类事物的属性和行为</li></ul><p>举例: 一只小猫</p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul><li>类是一类事物的描述, 是<strong>抽象的</strong></li><li>对象是一类事务的实例, 是<strong>具体的</strong></li><li><strong>类是对象的模板, 对象是类的实体</strong></li></ul><h4 id="创建和使用"><a href="#创建和使用" class="headerlink" title="创建和使用"></a>创建和使用</h4><p>感觉和C++有相通之处</p><p>导包, 如果在同一个包内可以不写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名称.类名称</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>成员变量没有进行赋值, 呢么将会有一个默认值, 规则和数组一样</p><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><h5 id="一个"><a href="#一个" class="headerlink" title="一个"></a>一个</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-class-storage.jpg" alt="java-class-storage"></p><h5 id="两个"><a href="#两个" class="headerlink" title="两个"></a>两个</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-class-storage-2.jpg" alt="java-class-storage-2"></p><h3 id="局部变量和成员变量"><a href="#局部变量和成员变量" class="headerlink" title="局部变量和成员变量"></a>局部变量和成员变量</h3><ul><li>局部变量: 随着方法进栈而诞生, 随着方法出栈而消失</li><li>成员变量:随着对象创建而诞生, 随着对象被垃圾回收而消失</li></ul><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>方法就是一种封装</li><li>关键字<code>private 私有化</code>也是一种封装</li><li>把一些细节信息隐藏, 对外界不可见</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>继承是多态的前提</li><li>继承类似<code>师徒关系</code>:师傅会多少都无偿传授给徒弟</li><li>继承主要解决的问题是:<code>共性抽取</code>, 举个栗子(滑稽保命), 在一个公司里有很多的员工, 员工属性:姓名, 性别。职称等就是他们的共性, 但根据职称的不同, 每个人的计算工资的方法不一样, 因此可以对<code>员工</code>这个共性进行抽取, 然后对<code>员工</code>类进行继承, 分别实现各自的计算工资的方法。</li><li>通俗讲就是可以免去<code>Ctrl + C/V</code>的麻烦</li><li>被继承的类可以叫做<code>父类</code>、<code>基类</code>、<code>超类</code></li><li>继承的类可以叫做<code>子类</code>、<code>派生类</code></li><li>继承的关键字是<code>extends</code></li></ul><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><p>Java是<strong>单继承</strong>, 即只能有一个父类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class one</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class two</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class three 这样定义是错误的!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span> <span class="keyword">extends</span> <span class="title">ClassOne</span>, <span class="title">ClassTwo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java可以<strong>多级继承</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grandson class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandsonClass</span> <span class="keyword">extends</span> <span class="title">ChildClass</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>父类可以拥有多个子类</p></li></ul><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li>如果在继承关系中成员变量, 则创建子类对象是, 访问有两种方式<ul><li>直接通过子类对象访问成员变量</li><li>间接通过成员方法访问成员变量</li></ul></li></ul><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li>就近原则, 谁调用执行谁的成员方法, 没有则<strong>向上</strong>寻找</li></ul><h6 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h6><ul><li>父子类名称相同, 参数列表也相同</li></ul><h6 id="重写-覆盖-Override"><a href="#重写-覆盖-Override" class="headerlink" title="重写/覆盖(Override)"></a>重写/覆盖(Override)</h6><ul><li><p>父子类名称相同, 参数列表不同</p></li><li><p>关键字<code>@Override</code>:可选, 起检测作用, 只要书写正确无也可覆盖</p></li><li><p><strong>返回值</strong>:子类方法返回值<strong>必须小于等于</strong>父类方法的返回值范围, 例如<code>Object</code>是<code>String</code>的父类, 则父类为<code>String</code>则子类不可以是<code>Object</code>, 父类为<code>Object</code>则子类可以是<code>String</code></p></li><li><p><strong>权限</strong>: 子类方法权限<strong>必须大于等于</strong>父类方法的权限修饰符</p><ul><li><code>public &gt; protected &gt; (default) &gt; private</code></li><li><code>defalut</code>: 表示什么都不写, 留空</li></ul></li><li><p>举例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>重写, 继承, 重载都是多态的一种表现形式</li></ul><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>当方法的局部变量和类成员变量重名, 根据<code>就近原则</code>, 优先使用局部变量</p><p>如果需要访问本类当中的成员变量, 需要使用格式;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>, 成员变量</span><br></pre></td></tr></table></figure><p>例子:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-this1.jpg" alt="java-this1"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-this2.jpg" alt="java-this2"></p><p><code>”通过谁调用的方法, 谁就是this“</code>: 用打印地址值来验证</p><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><ul><li>感觉跟C++一样, 只写一些自己不懂的</li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>特点:</p><ol><li>当第一次用到本类, 静态代码块执行唯一的一次</li><li>且比构造方法先执行！</li></ol><p>用途:常用于对静态成员的赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><h4 id="构造方法中"><a href="#构造方法中" class="headerlink" title="构造方法中"></a>构造方法中</h4><ul><li><code>super()</code>: 访问父类中的无参构造函数</li><li><code>super(paras...)</code>: 访问父类的有参构造函数</li></ul><h4 id="非构造方法"><a href="#非构造方法" class="headerlink" title="非构造方法"></a>非构造方法</h4><ul><li><code>super.xxx</code>: 访问父类中的成员变量</li><li><code>super.yyy(paras..)</code>: 访问父类中的成员函数yyy</li></ul><h3 id="this-vs-super"><a href="#this-vs-super" class="headerlink" title="this vs super"></a>this vs super</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-super_vs_this.jpg" alt="java-super_vs_this"></p><h3 id="标准类（Java-Bean）"><a href="#标准类（Java-Bean）" class="headerlink" title="标准类（Java Bean）"></a>标准类（Java Bean）</h3><p>一个标准类中通常有</p><ul><li>所有成员变量用<code>private</code>修饰</li><li>每一个成员变量都有一对<code>Getter/Setter</code>方法</li><li>一个无参构造</li><li>一个全参构造</li></ul><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><ul><li>只有右边的对象, 没有左边的名字和赋值运算符</li><li>只能使用一次, 下次使用需重新创建</li><li>也可以作为方法的参数和返回值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常</span></span><br><span class="line">Person one = <span class="keyword">new</span> Person();</span><br><span class="line">one.name = <span class="string">&quot;Lantern&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名对象</span></span><br><span class="line"><span class="keyword">new</span> Person().name = <span class="string">&quot;Lantern2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为参数</span></span><br><span class="line">methodParam(<span class="keyword">new</span> Scanner(System.in));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">methodReturnAndParam</span><span class="params">(Scanner sc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scanner(Systen.in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person array = <span class="keyword">new</span> Person[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 初始化为null</span></span><br><span class="line">Person one = <span class="keyword">new</span> Person(<span class="string">&quot;Lantern&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 将one中的地址值赋值给数组的0号元素</span></span><br><span class="line">array[<span class="number">0</span>] = one;</span><br></pre></td></tr></table></figure><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul><li><p>如果父类中的方法不确定如何进行某个方法体实现, 那么这应该是一个<strong>抽象方法</strong></p><ul><li>狗吃骨头猫吃鱼, 但动物吃什么没法具体描述, 那么就是一个抽象方法</li><li>正方形三角形可计算面积, 但是图形怎么计算面积没法具体描述, 那么就是一个抽象方法</li></ul></li></ul><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>定义<strong>抽象方法</strong>:在返回值前加上<code>abstract</code>关键字, 然后去掉大括号, 直接分号结束</p><p>定义<strong>抽象类</strong>: 在<code>class</code>之前加上<code>abstract</code>关键字</p><p><strong>抽象方法必须在抽象类中</strong></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>不能直接<code>new</code>抽象类对象, 必须用一个子类来继承抽象父类</li><li>子类<strong>必须</strong>覆盖重写抽象父类当中的所有的抽象方法</li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Animal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// code。。。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat eat fish.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>抽象类<strong>不能创建对象</strong></li><li>抽象类<strong>可以有</strong>构造方法, 供子类创建对象时, 初始化父类成员<ol><li>先执行父类构造方法</li><li>再执行子类构造方法</li></ol></li><li>抽象类<strong>不一定</strong>包含抽象方法, 有抽象方法<strong>必然</strong>是抽象类</li><li>抽象类的子类, <strong>必须</strong>覆盖重写父类中<strong>所有抽象方法</strong>, 除非子类也是抽象类</li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><strong>一种公共的规范</strong>, 只要符合标准就可以大家通用</li><li><strong>引用数据类型</strong>, 最重要的内容就是其中的抽象方法</li></ul><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可包含内容"><a href="#可包含内容" class="headerlink" title="可包含内容"></a>可包含内容</h4><ol><li>Java7<ol><li>常量</li><li>抽象方法</li></ol></li><li>Java8, 额外包含<ol><li>默认方法</li><li>静态方法</li></ol></li><li>Java9, 额外包含<ol><li>私有方法</li></ol></li></ol><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li>接口中的抽象方法修饰符<strong>必须</strong>是:<code>public abstract</code></li><li>这两个关键字<strong>可以</strong>选择性的<strong>省略</strong></li><li>方法的三要素可以随意定义</li></ol><h5 id="定义举例"><a href="#定义举例" class="headerlink" title="定义举例"></a>定义举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 以上全是抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><ul><li><p>接口不能直接使用, 必须要有一个<strong>实体类</strong>来实现接口</p></li><li><p>实现类必须覆盖重写接口中的抽象方法, 否则必须为抽象类</p></li><li><p>创建实现类的对象, 进行使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖重写接口中的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><blockquote><p>从java8开始允许在接口中定义默认方法</p></blockquote><ul><li>解决接口升级问题</li></ul><h5 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125; <span class="comment">// public 可省略</span></span><br></pre></td></tr></table></figure><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>接口的默认方法会被实现类继承</li><li>接口的默认方法可以被覆盖重写</li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote><p>从java8开始允许在接口中定义静态方法</p></blockquote><h5 id="定义格式-1"><a href="#定义格式-1" class="headerlink" title="定义格式"></a>定义格式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li>必须使用<strong>public static final</strong>三个关键字修饰(可省略, 默认)</li><li>其实就是接口的<strong>常量</strong>, 一旦赋值不可更改</li><li>必须进行<strong>赋值</strong></li><li>成员变量名建议使用<strong>大写字母</strong>, 符合命名规范</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 成员变量名 = 值;</span><br></pre></td></tr></table></figure><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p>接口没有<strong>静态代码块</strong>或<strong>构造方法</strong></p></li><li><p>一个类的直接父类是唯一的, 但一个类可以实现多个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名 <span class="keyword">implements</span> 接口1, 接口2 </span>&#123;</span><br><span class="line">    <span class="comment">// 覆写所有抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果实现类所实现的多个接口当中, 存在重复接口, 只用覆写一次</p></li><li><p>如果实现类没有覆盖重写所有接口当中的所有抽象方法, 那么实现类就必须是一个抽象类</p></li><li><p>如果实现类所实现的多个接口当中, 存在重复的默认方法, 那么实现类一定要对冲突的默认方法进行覆写</p></li><li><p>一个类如果直接父类当中的方法, 和接口当中的默认方法产生了冲突, 优先用父类当中的方法</p></li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><p>API<code>(Application Programming Interface)</code></p></li><li><p>Java API 文档</p></li></ul><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>一个可以解析基本类型和字符串的简单文本扫描器</p><p>例如, 以下代码使得用户可以从<code>System.in</code>中读取一个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 1.导包</span></span><br><span class="line"><span class="comment">// 2.创建, System.in 代表从键盘进行输入, 空格或回车进行截断</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">// 3.使用</span></span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();  <span class="comment">// 获得一个数字</span></span><br><span class="line">String str = sc.next(); <span class="comment">// 获得一个字符串</span></span><br></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><h5 id="计算输入的两数字和"><a href="#计算输入的两数字和" class="headerlink" title="计算输入的两数字和"></a>计算输入的两数字和</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br><span class="line"><span class="keyword">int</span> j = sc.nextInt();</span><br><span class="line">System.out.println(i + j);</span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>生成随机数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">int</span> num1 = r.nextInt(); <span class="comment">// 无参调用, 全范围</span></span><br><span class="line"><span class="keyword">int</span> num2 = r.nextInt(<span class="number">10</span>); <span class="comment">// 有参调用, [0, 10)</span></span><br></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li><p><code>java.util.ArrayList;</code></p></li><li><p><code>ArrayList&lt;E&gt;</code></p><ul><li><p><code>&lt;E&gt;</code>称为泛型, 也就是装在集合当中的所有元素都是统一类型</p></li><li><p>泛型只能是引用类型, 不能是基本类型</p></li></ul></li><li><p>ArrayList集合的长度可以随意改变</p></li><li><p>对于ArrayList集合来说, 直接打印得到的不是地址值, 而是内容</p></li><li><p>如果内容为空, 得到的是空的中括号: <code>[]</code></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建了一个ArrayList聚合, 集合的名称list, 里面装的全都是String字符串类型的数据</span></span><br><span class="line"><span class="comment">// 备注: 从JDK 1.7+ 开始, 右侧的尖括号内可以不写, 但尖括号还是要写的</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向集合中添加一些数据, 需要用到add方法</span></span><br><span class="line">list.add(<span class="string">&quot;Lantern&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Lantern2&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list.add(100);  // 报错！</span></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>不常用可以查询API文档</li><li><code>public boolean add(E e)</code>: 向集合当中添加元素, 参数的类型和泛型一致<ul><li>对于<code>ArrayList</code>集合来说, add添加动作一定是成功的, 所以返回值可用可不用, 但是对于其他集合来说, add动作不一定成功</li></ul></li><li><code>public E get(int index)</code>:从集合当中获取元素, 参数是索引编号, 返回值就是对应位置的元素</li><li><code>public E remove(int index)</code>: 从集合当中删除元素, 参数是索引编号, 返回值就是删除掉的元素</li><li><code>public int size()</code>: 获取集合的尺寸长度, 返回值为集合中包含的元素个数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Lantern&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Lantern1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Lantern2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从集合中获得元素, get 索引从0开始</span></span><br><span class="line">String name = list.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从集合中删除元素, remove 索引值从0开始</span></span><br><span class="line">String whoRemoved = list.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得集合的长度</span></span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合的元素</span></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储基本类型"><a href="#存储基本类型" class="headerlink" title="存储基本类型"></a>存储基本类型</h4><ul><li>如果要存储基本类型, 必须使用基本类型对应的<code>包装类</code>（引用数据类型, 包装类都位于java.lang下）</li></ul><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><ul><li><p>从JDK 1.5+开始, 支持自动装箱, 自动拆箱</p><ul><li>自动装箱: 基本类型 –&gt; 包装类</li><li>自动拆箱:包装类–&gt; 基本类型</li></ul></li><li><p>使用(以<code>Integer</code>为例)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; listInt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">listInt.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = listInt.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><code>java.lang.String</code></li><li>程序中所有的双引号字符串全是String类的对象</li><li>字符串内的内容不可改变</li><li>字符串可以共享</li><li>效果上相当于char[]字符数组, 但底层原理是byte[]字节数组【在<code>JDK 1.8</code>也就是<code>Java 8</code>中看到的其实是 <code>char[]</code>字符数组, <code>Java 9</code>中对其进行了优化, 使用了<code>byte[]</code>字节数组来节省空间(如使用字母时char需要两个字节, 而byte只需要一个字节)】</li></ul><p><code>Ctrl + Alt</code>点击<code>String</code>查看定义:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><ul><li><code>public String()</code>: 创建一个空白字符串, 不含有任何内容</li><li><code>public String(char[] array)</code>: 根据字符数组的内容, 来创建对应的字符串</li><li><code>public String(byte[] array)</code>: 根据字节数组的内容, 来创建对应的字符串</li><li><code>String str = &quot;xxxx&quot;</code>:直接创建, 也是对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] chars  = &#123;<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span> , <span class="number">99</span>&#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">System.out.println(str3);</span><br><span class="line"></span><br><span class="line">String string = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串的常量池"><a href="#字符串的常量池" class="headerlink" title="字符串的常量池"></a>字符串的常量池</h4><p>程序当中直接写上双引号的字符串, 就在字符串常量池中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br><span class="line">System.out.println(str3 == str2);</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><ul><li>对于基本类型来说, <code>==</code>是【数值】比较</li><li>对于引用类型来说, <code>==</code>是【地址值】的比较</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/java-string.jpg" alt="java-string"></p><ul><li>对于<code>&quot;&quot;</code>双引号直接括起来的字符串, 在常量池当中</li><li>读于<code>new</code>出来的字符串, 不在常量池中</li></ul><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="字符比较"><a href="#字符比较" class="headerlink" title="字符比较"></a>字符比较</h5><ul><li><p><code>public boolean equals(Object obj)</code>: 参数可以是任何对象, 只有参数是一个字符串并内容相同的才会给<code>true</code></p><ul><li><p>任何对象都可以用<code>Object</code>进行接受</p></li><li><p>具有对称性<code>a.equals(b)</code>和<code>b.equlas(a)</code>效果相同</p></li><li><p>如果比较双方一个常量一个变量, 推荐把<code>常量</code>字符写在<code>前面</code></p><ul><li><p>推荐: <code>&quot;abc&quot;.equals(str)</code></p></li><li><p>不推荐:<code>str.equals(&quot;abc&quot;)</code></p></li><li><p>理由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span>.equals(str)); <span class="comment">// false</span></span><br><span class="line">System.out.println(str.equals(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// 报错:空指针异常 NullPointerException</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>public boolean equalsIgnoreCase(String str)</code>: 参数是字符串, 忽略大小写判断</p></li></ul><p>使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">System.out.println(str2.equals(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>.equals(str1));</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(str3.equalsIgnoreCase(str2));</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h5 id="字符获取"><a href="#字符获取" class="headerlink" title="字符获取"></a>字符获取</h5><ul><li><code>public int length()</code>: 获取字符串当中含有的字符个数, 拿到字符串长度</li><li><code>public String concat(String str)</code>: 将当前字符串和参数字符串拼接成为返回值(新的字符串)</li><li><code>public char charAt(int index)</code>: 获取指定索引位置的单个字符(从0开始)</li><li><code>public int indexOf(String str)</code>: 查找参数字符串在本字符串当中首次出现的索引位置</li></ul><h5 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h5><ul><li><code>public String subtring(int index)</code>: 截取从参数位置一直到字符串末尾, 返回新字符串</li><li><code>public String substring(int begin, int end)</code>: 截取从begin开始, 一直到end结束, 中间的字符串。 备注: <code>[begin, end)</code>, 包含左边, 不含右边</li></ul><h5 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h5><ul><li><code>public char[] toCharArray()</code>: 将当前字符串拆分成为字符数组作为返回值</li><li><code>public byte[] getBytes()</code>:获取当前字符串底层的字节数组</li><li><code>public String replace(CharSequence oldString, CharSequence newString)</code>: 将所有出现的老字符串替换为新的字符串, 返回替换之后的新字符串</li></ul><h5 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h5><ul><li><code>public String[] split(String regex)</code>: 根据regex的规则, 将字符串切分成若干部分(由于<code>,</code>用于切分因此生成的字符串数组中的字符串不包含<code>,</code>)</li><li>实际上, <code>split</code>方法的参数其实是正则表达式, 因此当我们<code>string.split(&#39;.&#39;)</code>时并不会用<code>.</code>进行切割, 因为<code>.</code>在正则中有特殊的含义, 因此我们必须写<code>string.split(&#39;\\.&#39;)</code>, 用<code>\\</code>来转义</li></ul><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul><li><p><code>java.util.Arrays</code>: 一个与数组相关的工具类, 里面提供了大量的静态方法, 用来实现数组的常见操作</p></li><li><p><code>public static String toString(数组)</code>:将参数数组变成字符串</p></li><li><p><code>public static void sort(数组)</code>: 按默认升序(从小到大)对数组元素进行排序</p><ul><li>如果时数值, sort默认按照默认升序(从小到大)对数组元素进行排序</li><li>如果时字符串, 按字母升序排序</li><li>如果时自定义类型, 则必须要有<code>Comparrable</code>或者<code>Comparator</code>接口的支持</li></ul></li></ul><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul><li><code>java.util.Math</code>: 数学工具类, 提供了大量静态方法, 完成于数学运算相关的操作</li><li><code>public static double abs(double num)</code>: 获取绝对值</li><li><code>public static double ceil(double num)</code>: 向上取整</li><li><code>public static double floor(double num)</code>: 向下取整</li><li><code>public static long round(double num)</code>: 四舍五入</li><li><code>Math.PI</code>:近似圆周率</li></ul><h2 id="Java项目结构"><a href="#Java项目结构" class="headerlink" title="Java项目结构"></a>Java项目结构</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:%5CBlog%5Cblog-code%5Csource%5C_posts%5Cnote%5Clanguage%5Cjava-note%5Cjava-project_structure.png" alt="java-project_structure"></p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><ul><li><code>iml</code>: 配置文件</li><li><code>src</code>: 代码</li><li><code>External Libraries</code>: JDK的文件</li><li><code>psvm</code>一键生成<code>public static void main(String[] args)</code></li><li><code>sout</code>一键生成<code>System.out.println();</code></li><li><code>Alt + Insert</code> 一键生成<code>Getter/Setter</code>方法</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="http://lantern.cool">Lantern</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://lantern.cool/note-language-java-note/">http://lantern.cool/note-language-java-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lantern.cool" target="_blank">Lantern's 小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files@latest/img/pexels-greg-contreras-3177804.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/wp-games-2020wd/" title="2020 网鼎杯"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/write_up.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2020 网鼎杯</div></div></a></div><div class="next-post pull-right"><a href="/wp-games-buuctf/" title="BUUOJ 题库练习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/write_up.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUUOJ 题库练习</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/lantern.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Lantern</div><div class="author-info__description">一位二进制萌新</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lantern-r"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lantern-r" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:l2674318405@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Never Give Up</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">Java语言开发环境的搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94JVM"><span class="toc-number">2.1.</span> <span class="toc-text">Java虚拟机——JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRE-%E5%92%8C-JDK"><span class="toc-number">2.2.</span> <span class="toc-text">JRE 和 JDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">3.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.2.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.2.</span> <span class="toc-text">调用流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">3.6.3.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.6.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.7.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.7.1.</span> <span class="toc-text">动态初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.7.2.</span> <span class="toc-text">静态初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.7.3.</span> <span class="toc-text">省略格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.7.4.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8%EF%BC%88ArrayIndexOutOfBoundsException%EF%BC%89"><span class="toc-number">3.7.4.1.</span> <span class="toc-text">数组越界异常（ArrayIndexOutOfBoundsException）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8-NullPointerException"><span class="toc-number">3.7.4.2.</span> <span class="toc-text">空指针异常(NullPointerException)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.7.5.</span> <span class="toc-text">数组长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">3.8.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-Stack%EF%BC%89"><span class="toc-number">3.8.1.</span> <span class="toc-text">栈(Stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86-Heap"><span class="toc-number">3.8.2.</span> <span class="toc-text">堆(Heap)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area"><span class="toc-number">3.8.3.</span> <span class="toc-text">方法区(Method Area)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native-Method-Stack"><span class="toc-number">3.8.4.</span> <span class="toc-text">本地方法栈(Native Method Stack)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Register%EF%BC%89"><span class="toc-number">3.8.5.</span> <span class="toc-text">寄存器（Register）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">3.9.</span> <span class="toc-text">面向对象的思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.10.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">3.10.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.10.2.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-number">3.10.3.</span> <span class="toc-text">关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.10.4.</span> <span class="toc-text">创建和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">3.10.5.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA"><span class="toc-number">3.10.5.1.</span> <span class="toc-text">一个</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA"><span class="toc-number">3.10.5.2.</span> <span class="toc-text">两个</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.11.</span> <span class="toc-text">局部变量和成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">3.12.</span> <span class="toc-text">面向对象的三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">3.12.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.12.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.12.2.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.12.2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.12.2.3.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">3.12.2.4.</span> <span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-Overload"><span class="toc-number">3.12.2.4.1.</span> <span class="toc-text">重载(Overload)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96-Override"><span class="toc-number">3.12.2.4.2.</span> <span class="toc-text">重写&#x2F;覆盖(Override)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.12.3.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.13.</span> <span class="toc-text">this 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.14.</span> <span class="toc-text">static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">3.14.1.</span> <span class="toc-text">静态代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.15.</span> <span class="toc-text">super 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD"><span class="toc-number">3.15.1.</span> <span class="toc-text">构造方法中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.15.2.</span> <span class="toc-text">非构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-vs-super"><span class="toc-number">3.16.</span> <span class="toc-text">this vs super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%B1%BB%EF%BC%88Java-Bean%EF%BC%89"><span class="toc-number">3.17.</span> <span class="toc-text">标准类（Java Bean）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.18.</span> <span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">3.19.</span> <span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">3.20.</span> <span class="toc-text">抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">3.20.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.20.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">3.20.3.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.20.4.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.21.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">3.21.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8C%85%E5%90%AB%E5%86%85%E5%AE%B9"><span class="toc-number">3.21.2.</span> <span class="toc-text">可包含内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.21.3.</span> <span class="toc-text">抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">3.21.3.1.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.21.3.2.</span> <span class="toc-text">定义举例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">3.21.3.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.21.3.4.</span> <span class="toc-text">使用举例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">3.21.4.</span> <span class="toc-text">默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.21.4.1.</span> <span class="toc-text">定义格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">3.21.4.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.21.5.</span> <span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">3.21.5.1.</span> <span class="toc-text">定义格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="toc-number">3.21.6.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">3.21.7.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-number">4.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scanner"><span class="toc-number">4.1.</span> <span class="toc-text">Scanner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">4.1.1.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%BE%93%E5%85%A5%E7%9A%84%E4%B8%A4%E6%95%B0%E5%AD%97%E5%92%8C"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">计算输入的两数字和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random"><span class="toc-number">4.2.</span> <span class="toc-text">Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">4.3.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">存储基本类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">4.4.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.4.1.</span> <span class="toc-text">创建字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">4.4.2.</span> <span class="toc-text">字符串的常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.4.3.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%AF%94%E8%BE%83"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">字符比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%8E%B7%E5%8F%96"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">字符获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">字符串截取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">字符串转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2"><span class="toc-number">4.4.3.5.</span> <span class="toc-text">字符串切割</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays"><span class="toc-number">4.5.</span> <span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">4.6.</span> <span class="toc-text">Math</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">Java项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA"><span class="toc-number">6.</span> <span class="toc-text">IDEA</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/note-tool-z3/" title="Z3"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files@latest/img/pexels-nick-rtr-3129443.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Z3"></a><div class="content"><a class="title" href="/note-tool-z3/" title="Z3">Z3</a><time datetime="2022-05-14T00:43:19.000Z" title="更新于 2022-05-14 00:43:19">2022-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CVE-d-link-dir-505/" title="D-Link Dir-505 便携路由器越界漏洞分析"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files@latest/img/pexels-sebastiaan-stam-1097456.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="D-Link Dir-505 便携路由器越界漏洞分析"></a><div class="content"><a class="title" href="/CVE-d-link-dir-505/" title="D-Link Dir-505 便携路由器越界漏洞分析">D-Link Dir-505 便携路由器越界漏洞分析</a><time datetime="2021-11-09T17:44:37.000Z" title="更新于 2021-11-09 17:44:37">2021-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CVE-d-link-dir-645/" title="D-Link Dir-645 路由器溢出漏洞分析"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files@latest/img/pexels-sebastiaan-stam-1097456.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="D-Link Dir-645 路由器溢出漏洞分析"></a><div class="content"><a class="title" href="/CVE-d-link-dir-645/" title="D-Link Dir-645 路由器溢出漏洞分析">D-Link Dir-645 路由器溢出漏洞分析</a><time datetime="2021-11-08T17:44:37.000Z" title="更新于 2021-11-08 17:44:37">2021-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/wp-games-buuctf/" title="BUUOJ 题库练习"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files/img/write_up.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="BUUOJ 题库练习"></a><div class="content"><a class="title" href="/wp-games-buuctf/" title="BUUOJ 题库练习">BUUOJ 题库练习</a><time datetime="2021-11-04T19:10:31.000Z" title="更新于 2021-11-04 19:10:31">2021-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CVE-d-link-dir-815/" title="D-Link DIR-815 路由器多次溢出漏洞分析"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Lantern-r/cdn_files@latest/img/pexels-sebastiaan-stam-1480690.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="D-Link DIR-815 路由器多次溢出漏洞分析"></a><div class="content"><a class="title" href="/CVE-d-link-dir-815/" title="D-Link DIR-815 路由器多次溢出漏洞分析">D-Link DIR-815 路由器多次溢出漏洞分析</a><time datetime="2021-10-28T17:44:37.000Z" title="更新于 2021-10-28 17:44:37">2021-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By Lantern</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'eba91da4778bec626f83',
      clientSecret: '28e43c46124583d177809ce45217e5671439363c',
      repo: 'Lantern-r.github.io',
      owner: 'Lantern-r',
      admin: ['Lantern-r'],
      id: '53ddb18aefa9b2b5c098994e577cf7fd',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Just,Learn,Fast" data-fontsize="15px" data-random="false" async></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'UA-165381350-1', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>